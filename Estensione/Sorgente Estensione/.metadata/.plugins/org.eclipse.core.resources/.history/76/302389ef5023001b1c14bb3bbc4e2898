package server;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;

import data.Data;
import data.TrainingDataException;
import tree.LeafNode;
import tree.RegressionTree;
import tree.SplitNode;

/**
 * Classe che gestisce le singole connessioni con un client, il quale invia le
 * richieste specifiche dell'utente e riceve le risposte alla richiesta elaborate 
 * dal server.
 *  Estende la classe Thread in modo da poter creare ed eseguire thread
 */

 class ServerOneClient extends Thread{ 

	 /**
	  * Attributo che identifica la socket per la connesione col client
	  */
	private Socket socket;
	/**
	 * In stream di input usato dal server per comunicare col client
	 */
	private ObjectInputStream in;
	/**
	 * Out stream di output usato dal server per comunicare col client
	 */
	private ObjectOutputStream out;
	
/**
 * Costruttore di classe che inizializza gli attributi in,out e socket.
 * Avvia il thread attraverso il metodo start
 * @throws IOException lanciata se occorre un errore nella comunicazione col client
 */
public ServerOneClient(Socket s) throws IOException{

		this.socket=s;
		in=new ObjectInputStream (socket.getInputStream());
		out= new ObjectOutputStream(socket.getOutputStream());
		start();
}
	
/** Riscrive il metodo run della superclasse Thread al fine di gestire le richieste del client 
 *  ed ottenere in questo modo i risultati richiesti.
 */
public void run() {
	try {
		RegressionTree tree=null;
		Data trainingSet=null;
		String tableName="";
		Object anw=null;
		while(true) {
			anw= in.readObject();
			
			if(anw.equals(0)) {
				try{
					tableName=(String) in.readObject();
					trainingSet= new Data(tableName);	
					out.writeObject("OK");
				}
				catch(TrainingDataException e){
					System.out.println(e);
					out.writeObject("Some errors occurred with the table specified. Try again!");	
					}
				
			
			}else if(anw.equals(1)){
				
				tree=new RegressionTree(trainingSet);
				try {
					tree.salva(tableName+".dmp");
					
				} catch (IOException e) {
					
					System.out.println(e.toString());
				}
	
			}else if (anw.equals(2)){
				
				tableName= (String) in.readObject();
				try {
					tree=RegressionTree.carica(tableName+".dmp");
					out.writeObject("OK");
				} catch (ClassNotFoundException | IOException e) {
					out.writeObject(tableName +".dmp doesn't exist. Try again!");	
					
				}
				
				
			}else if(anw.equals(4)) {
				out.writeObject(tree.printTree());
				
			}else if(anw.equals(5)) {
					tree.printRules(out);
					out.writeObject("END"); //finita la stampa delle regole
				
			}
			else if(anw.equals(6)){
				
							try {
								Double pred = predictClass(tree,in, out);
								out.writeObject("OK");
								out.writeObject(pred);
							}catch(UnknownValueException e) {

								out.writeObject(e.getMessage());	
							}
						
				
				
		
			}
		}
			}catch( IOException e) {
			try {
				socket.close();
			}catch(IOException e1) {
				System.out.println(e1);
			}
		}catch(ClassNotFoundException  e2){
			System.out.println(e2);
		}
		finally {
			try {
				socket.close();
			}catch(IOException e) {
				System.out.println("Socket not closed!");
			}
		}
	
	} 
	
	
	/**
	 * Mostra all'utente le informazioni di ciascuno split dell'albero
	 * e per il corrispondente attributo acquisisce il valore dell'esempio da predire
	 * da tastiera.<br>
	 * Se il nodo root corrente è leaf termina l'acquisizione e mostra all'utente la predizione
	 * per l’attributo classe, altrimenti invoca ricorsivamente sul figlio di root 
	 * nell'array childTree individuato dal valore acquisito da tastiera. <br>
	 * Il metodo solleva l'eccezione UnknownValueException quando la risposta 
	 * dell’utente non permette di selezionare un ramo valido del nodo di split, e 
	 * l'eccezione sarà gestita nel metodo che invoca predictClass().
	 * 
	 * @param tree albero su cui si effettua la predizione
	 * @param out canale di output per la comunicazione col il client
	 * @param in canale di input per la comunicazione col il client
	 * @throws UnknownValueException lanciata se l'utente sceglie l'indice 
	 * di un ramo inesistente
	 * @throws IOException lanciata nel momento in cui vi e' un errore di comunicazione col client
	 * @throws ClassNotFoundException lanciata quando la classe di cui si sta cercando l'istanza non esiste
	 */
	private Double predictClass(RegressionTree tree,ObjectInputStream in, ObjectOutputStream out ) throws UnknownValueException, IOException, ClassNotFoundException{ //uso di RTTI			
		if(tree.getRoot() instanceof LeafNode) {
			
			return ((LeafNode) tree.getRoot()).getPredictedClassValue();
		}else
		  {
			out.writeObject("QUERY");
			int risp;
			out.writeObject(((SplitNode)tree.getRoot()).formulateQuery());
			risp=(int)in.readObject();
			if(risp<0 || risp>=tree.getRoot().getNumberOfChildren()) {
				throw new UnknownValueException("The answer should be an integer between 0 and " +(tree.getRoot().getNumberOfChildren()-1)+"!");
			}else {
				return predictClass(tree.getChildTree(risp),in,out);
			}
	      }
		
	}
	
}
	
